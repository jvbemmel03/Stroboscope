/*
Script for stroboscoop driven by PWM signals Arduino. Two PWM signals are generated by the PWM libraries. Pin D9 generates a low frequency signal
for controlling the over all frequency of the stroboscope. Pin 3 controls the intensity of the stroboscope. This script contains two modes: manual and automatic.
By making use of the following components: ADS1115, LCD 16x2 I2C, potentiometers, encoder (EC11) and toggle switches.

connections:
toggle switch: D7
PWM frequency output: D9
PWM intensity output: D3
detection frequency: D8
Encoder: D2 & D4
Switch Encoder: D6
SDA: A5
SCL: A4

Jasper van Bemmel 13-08-2025
*/

// libraries
#include <TimerOne.h>
#include <PWM.h>
#include <ADS1X15.h>
#include <LiquidCrystal_I2C.h>
#include <Encoder.h>

// pin definitions
const int switchPin = 7;      
const int signalPin = 8;
const int pwmPin1 = 9;
const int pwmPin2 = 3;
const int encoderButton = 5;
const int encoderCLK = 2;
const int encoderDT = 4;

int pwmFreq2 = 500;          // frequency pwm2
bool lastSwitchState = false; // bool for switching modes

// variables encoder
long lastRawValue = 0;
int lastClickValue = 0;
float freqManual = 0.0; // for manual mode
float freqAuto = 0.0;   // for auto mode

// define components I2C
LiquidCrystal_I2C lcd(0x27,16,2);
ADS1115 ADS(0x48);
Encoder roteryEncoder(encoderCLK, encoderDT);  // CLK on 2, DT on 4

// function for detecting frequency automatic mode
float measureFrequency() {
  unsigned long lastPulseTime = 0;
  float frequency = 0;
  int lastState = LOW;
  unsigned long startTime = micros();  // start of measuring period
  const unsigned long timeout = 500000; // timeout for when no frequency is detected

  while (frequency == 0) {
    int state = digitalRead(signalPin);

    // detect falling flank
    if (lastState == HIGH && state == LOW) {
      unsigned long now = micros();

      if (lastPulseTime != 0) {
        unsigned long period = now - lastPulseTime;
        frequency = 1000000.0 / period; // frequentie in Hz
      }

      lastPulseTime = now;
    }

    lastState = state;

    // check timeout
    if (micros() - startTime >= timeout) {
      frequency = 0;  // no frequency detected, give 0 Hz
      break;
    }
  }

  if (frequency > 400){ frequency = 0; }
  return frequency;
}

void setup() {
  Serial.begin(115200);

  // define pinmodes
  pinMode(switchPin, INPUT_PULLUP);
  pinMode(encoderButton, INPUT_PULLUP);
  pinMode(signalPin, INPUT);

  // initialize timers
  Timer1.initialize(0);
  InitTimersSafe();

  // initialize ADS
  ADS.begin();
  ADS.setGain(0);

  // initialize lcd
  lcd.init();
  lcd.backlight();
  lcd.clear();
  Wire.begin();

  lcd.setCursor(0, 0); lcd.print("  STROBOSCOPE");
  lcd.setCursor(0, 1); lcd.print("  CONTROLLER");

  delay(1500);
  lcd.clear();

  lcd.setCursor(0, 0); lcd.print("    THALES");
  lcd.setCursor(0, 1); lcd.print("   NEDERLAND");

  delay(1500);
  lcd.clear();
}

void loop() {
  bool currentSwitchState = (digitalRead(switchPin) == HIGH);  // HIGH = manual mode

  if (currentSwitchState != lastSwitchState) {
    lcd.clear();

    if (currentSwitchState){
      lcd.setCursor(0, 0); lcd.print("  MANUAL MODE   ");
    }
    else {
      lcd.setCursor(0, 0); lcd.print("   AUTO MODE   ");
    }
    delay(1000);
    lcd.clear();

    lastClickValue = 0;
    roteryEncoder.write(0);  // reset encoder position

    lcd.setCursor(6, 0); lcd.print("PW(%)");
    lcd.setCursor(12, 0); lcd.print("I(%)");
    lcd.setCursor(0, 0); lcd.print("f(Hz)");

    lastSwitchState = currentSwitchState;
  }

  // read and map values ADS
  int16_t val_1 = ADS.readADC(1);
  int16_t val_2 = ADS.readADC(2);
  int pwpot = map(val_1, 1000, 25000, 0,  1023);
  int Ipot = map(val_2, 1000, 25000, 0,  255);
  int pwpot_print = map(val_1, 1000, 25000, 0,  100);
  int Ipot_print = map(val_2, 1000, 25000, 0,  100);

  char buffer[8];

  // === Manual mode ===
  if (currentSwitchState) {
    long rawValue = roteryEncoder.read();
    int clickValue = rawValue / 4;

    if (clickValue != lastClickValue) {
      int delta = clickValue - lastClickValue;
      lastClickValue = clickValue;

      freqManual += delta * 0.1;

      // limits readings
      if (freqManual > 100.0) freqManual = 0.0;
      else if (freqManual < 0.0) freqManual = 100.0;
    }

    if (digitalRead(encoderButton) == LOW) {
      unsigned long pressStart = millis();

      while (digitalRead(encoderButton) == LOW) {
        if (millis() - pressStart > 600) {
          // long press â†’ reset frequency
          freqManual = 0.0;
          while (digitalRead(encoderButton) == LOW) delay(10);
          break;
        }
        delay(10);
      }

      if (millis() - pressStart <= 600) {
        if (freqManual <= 90) {
          freqManual += 10; 
        }
        else {
          freqManual = freqManual - 90;
        }
      }
    }

    lcd.setCursor(7, 1);
    if (pwpot_print < 1) {
      pwpot = 0;
      lcd.print("---");
    } else if (pwpot_print > 100) {
      pwpot = 1023;
      lcd.print("100");
    } else {
      lcd.print(dtostrf(pwpot_print,3,0, buffer));
    }

    lcd.setCursor(12, 1);
    if (Ipot_print < 1) {
      Ipot = 0;
      lcd.print("---");
    } else if (Ipot_print > 100) {
      Ipot = 255;
      lcd.print("100");
    } else {
      lcd.print(dtostrf(Ipot_print,3,0, buffer));
    }

    lcd.setCursor(0, 1);
    lcd.print("     ");  // clear old data
    lcd.setCursor(0, 1);
    if (freqManual < 0.1) Ipot = 0;
    lcd.print(dtostrf(freqManual, 4, 1, buffer));

    // PWM settings
    Timer1.setPeriod(1000000 / freqManual);
    Timer1.pwm(pwmPin1, pwpot);
    SetPinFrequency(pwmPin2, pwmFreq2);
    pwmWrite(pwmPin2, Ipot);
  }

  // === AUTO mode ===
  else {
    long rawValue = roteryEncoder.read();
    int clickValue = rawValue / 4;

    if (clickValue != lastClickValue) {
      int delta = clickValue - lastClickValue;
      lastClickValue = clickValue;

      freqAuto += delta * 0.1;
      freqAuto = constrain(freqAuto, 0.0, 5.0);

    }

    lcd.setCursor(6, 0); lcd.print("PW(%)");
    lcd.setCursor(12, 0); lcd.print("I(%)");
    lcd.setCursor(0, 0); lcd.print("f(Hz)");

    lcd.setCursor(7, 1);
    if (pwpot_print < 1) {
      pwpot = 0;
      lcd.print("---");
    } else if (pwpot_print > 100) {
      pwpot = 1023;
      lcd.print("100");
    } else {
      lcd.print(dtostrf(pwpot_print,3,0, buffer));
    }

    lcd.setCursor(12, 1);
    if (Ipot_print < 1) {
      Ipot = 0;
      lcd.print("---");
    } else if (Ipot_print > 100) {
      Ipot = 255;
      lcd.print("100");
    } else {
      lcd.print(dtostrf(Ipot_print,3,0, buffer));
    }

    lcd.setCursor(1, 1);
    lcd.print("    ");
    lcd.setCursor(1, 1);
    lcd.print(dtostrf(freqAuto, 3, 1, buffer));

    float freqDetected = measureFrequency();
    
    if (freqDetected < 200) {
    
      // PWM settings
      Timer1.setPeriod(1000000 / (freqAuto + freqDetected));
      Timer1.pwm(pwmPin1, pwpot);
      SetPinFrequency(pwmPin2, pwmFreq2);
      pwmWrite(pwmPin2, Ipot);
    }
  }
  
  delay(100);
}
